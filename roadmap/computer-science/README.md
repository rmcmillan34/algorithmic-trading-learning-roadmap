# Computer Science

## Overview

Computer Science provides the theoretical and practical foundation for modern software systems. This domain covers essential programming concepts, algorithmic thinking, system-level knowledge, and performance optimization — all of which are critical for building reliable and efficient algorithmic trading platforms.

While not all topics here are mandatory for applied trading work, this domain ensures a deep and transferable understanding of how computers operate and how software is structured at every level.

---

## Learning Tracks

The topics below are organized in a suggested order of priority. Each can be studied independently or as part of a structured journey toward system-level mastery.

| Topic | Description | Status |
|-------|-------------|--------|
| [Programming](./programming/) | Core concepts, best practices, and foundational programming skills across languages | 🟢 Mandatory |
| [Python](./python/) | High-level, versatile language used heavily in trading, ML, and scripting | 🟢 Mandatory |
| [C++](./c++) | High-performance language for speed-critical systems and backend infrastructure | 🟢 Mandatory |
| [Object-Oriented Programming](./object-oriented-programming/) | Design with encapsulation, inheritance, polymorphism, and OOP principles | 🟢 Mandatory |
| [Data Structures](./data-structures/) | Arrays, lists, stacks, heaps, graphs, and trees — essential for problem solving | 🟢 Mandatory |
| [Algorithms](./algorithms/) | Algorithm design and analysis for optimization, search, sort, and problem solving | 🟢 Mandatory |
| [Assembly Language](./assembly-language/) | Low-level programming for understanding CPUs, registers, and memory | 🟣 Optional |
| [Concurrency](./concurrency/) | Multithreading, synchronization, and parallel programming | 🟡 Recommended |
| [Network Programming](./network-programming/) | Sockets, TCP/IP, HTTP, and real-time communication systems | 🟡 Recommended |
| [Compilers](./compilers/) | Language parsing, code generation, and interpreter design | 🟣 Optional |
| [Computer Architecture](./computer-architecture/) | From gates to CPUs — understand how computers execute code at the hardware level | 🟣 Optional |
| [Operating Systems](./operating-systems/) | Process scheduling, memory, filesystems, and syscalls | 🟡 Recommended |
| [Theory of Computation](./theory-of-computation/) | Automata, complexity theory, decidability, and formal languages | ⚪ Advanced |
| [CUDA](./cuda/) | GPU programming for parallel processing and high-performance computing | ⚪ Advanced |
---

## Learning Priorities

| Symbol | Priority | Intended Learner |
|--------|----------|------------------|
| 🟢 | **Mandatory** | All developers, especially in trading, ML, and backend |
| 🟡 | **Recommended** | Useful for deeper engineering and system design |
| 🟣 | **Optional** | Great for low-level insight, systems programming, or interest |
| ⚪ | **Advanced** | Mostly theoretical; long-term enrichment or academic CS |

---

## Suggested Study Order

1. `programming/`
2. `python/`
3. `object-oriented-programming/`
4. `data-structures/`
5. `algorithms/`
6. `c++/`
7. Optional depth: `concurrency` → `network programming` → `OS` → `architecture` → `compilers` → `theory` → `assembly language` → `CUDA`

---

## Integration with Other Domains

- For scripting and automation: see [`linux/`](../general-skills/linux/)
- For systems deployment and containerization: see [`cloud-devops/`](../cloud-devops/)
- For machine learning foundations: see [`artificial-intelligence/`](../artificial-intelligence/)
- For quantitative modeling: see [`finance/`](../finance/)

---

> ✍️ This domain is foundational — it doesn't prescribe a single path but provides the building blocks for all others. Learners should follow their needs, interests, or target roles when prioritizing topics.

